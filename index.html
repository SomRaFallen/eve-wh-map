<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>EVE — Карта перемещений ВХ</title>
<script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
<style>
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:16px}
button{font-size:1rem;padding:8px;margin:4px}
#map{width:100%;height:420px;border:1px solid #ddd;margin-top:12px}
#results{margin-top:12px}
#zkbKills{margin-top:12px;border:1px solid #ddd;padding:8px;height:200px;overflow:auto;background:#f9f9f9}
.note{color:#555;font-size:0.9rem}
</style>
</head>
<body>
<h2>EVE Online — Карта перемещений ВХ</h2>
<p class="note">Карта перемещений персонажа только по вормхолам (ВХ). Последние киллмейлы берутся с ZKillboard.</p>

<div>
<button id="authBtn">Авторизоваться через EVE Online</button>
<button id="logoutBtn" style="display:none">Выйти</button>
</div>
<div id="authInfo" class="note"></div>
<div>
<button id="buildMapBtn" style="display:none">Построить карту ВХ</button>
<button id="savePathBtn" style="display:none">Сохранить путь</button>
</div>

<div id="status" class="note"></div>
<div id="map"></div>
<div id="results"></div>
<div id="zkbKills"><strong>Последние киллмейлы (ZKB):</strong><br></div>

<script>
const CLIENT_ID = '5a40c55151c241e3a007f2562fd4e1dd';
const REDIRECT_URI = window.location.origin + window.location.pathname;
const SCOPES = 'esi-location.read_location.v1';
const PROXY_URL = 'https://eve-proxy.onrender.com/exchange';
const RENDER_SERVER = 'https://eve-proxy.onrender.com';
const ZKB_BASE = 'https://zkillboard.com/api/characterID/';

const authBtn = document.getElementById('authBtn');
const logoutBtn = document.getElementById('logoutBtn');
const authInfo = document.getElementById('authInfo');
const buildMapBtn = document.getElementById('buildMapBtn');
const savePathBtn = document.getElementById('savePathBtn');
const status = document.getElementById('status');
const results = document.getElementById('results');
const zkbKillsDiv = document.getElementById('zkbKills');
const container = document.getElementById('map');

let historyWH = [];

function login(){
    const state = Math.random().toString(36).substring(2);
    const url = `https://login.eveonline.com/v2/oauth/authorize?response_type=code&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&client_id=${CLIENT_ID}&scope=${encodeURIComponent(SCOPES)}&state=${state}`;
    window.location.href = url;
}

async function exchangeCodeForToken(code){
    const r = await fetch(PROXY_URL, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ code })
    });
    if(!r.ok) throw new Error('Ошибка обмена кода на токен');
    return await r.json();
}

async function getCharacterInfo(token){
    const r = await fetch('https://esi.evetech.net/verify/',{headers:{Authorization:`Bearer ${token}`}});
    if(!r.ok) throw new Error('Ошибка проверки токена');
    return await r.json();
}

function logout(){
    localStorage.removeItem('eve_token');
    localStorage.removeItem('eve_char');
    authInfo.textContent = '';
    authBtn.style.display = 'inline-block';
    logoutBtn.style.display = 'none';
    buildMapBtn.style.display = 'none';
    savePathBtn.style.display = 'none';
}

async function handleAuth(){
    const params = new URLSearchParams(window.location.search);
    let char, token;

    if(params.has('code')){
        const code = params.get('code');
        try{
            const tokenData = await exchangeCodeForToken(code);
            token = tokenData.access_token;

            const verify = await getCharacterInfo(token);
            char = verify;
            localStorage.setItem('eve_token', token);
            localStorage.setItem('eve_char', JSON.stringify(char));

            authInfo.textContent = `Авторизован: ${char.CharacterName} (ID: ${char.CharacterID})`;
            authBtn.style.display = 'none';
            logoutBtn.style.display = 'inline-block';
            buildMapBtn.style.display = 'inline-block';
            savePathBtn.style.display = 'inline-block';

            // === Сохраняем текущую систему сразу после авторизации ===
            const defaultSystem = { system_id: 'J000000', system_name: 'J000000' }; 
            await fetch(`${RENDER_SERVER}/location`, {
                method: 'POST',
                headers: { 'Content-Type':'application/json' },
                body: JSON.stringify({
                    characterID: char.CharacterID,
                    systemID: defaultSystem.system_id,
                    systemName: defaultSystem.system_name
                })
            });

            window.history.replaceState({}, document.title, window.location.pathname);

        }catch(e){
            console.error(e);
            authInfo.textContent = 'Ошибка авторизации: '+e.message;
        }
    } else {
        token = localStorage.getItem('eve_token');
        const charData = localStorage.getItem('eve_char');
        if(token && charData){
            char = JSON.parse(charData);
            authInfo.textContent = `Авторизован: ${char.CharacterName} (ID: ${char.CharacterID})`;
            authBtn.style.display = 'none';
            logoutBtn.style.display = 'inline-block';
            buildMapBtn.style.display = 'inline-block';
            savePathBtn.style.display = 'inline-block';
        }
    }
}

authBtn.addEventListener('click', login);
logoutBtn.addEventListener('click', logout);
handleAuth();

function isWormholeSystem(name){ return /^J\d+/i.test(name); }

function drawNetwork(nodesArr, edgesArr){
    const nodes = new vis.DataSet(nodesArr.map((n,i)=>({id:i,label:n})));
    const edges = new vis.DataSet(edgesArr.map(e=>({from:e.from,to:e.to})));
    const data = { nodes, edges };
    const options = { physics:{stabilization:true, barnesHut:{gravitationalConstant:-8000}} };
    new vis.Network(container, data, options);
}

async function fetchZKBBattles(characterID){
    try{
        const r = await fetch(`${ZKB_BASE}${characterID}/recent/`);
        if(!r.ok) { zkbKillsDiv.innerHTML += 'Ошибка ZKB: '+r.status; return; }
        const data = await r.json();
        zkbKillsDiv.innerHTML = '<strong>Последние киллмейлы (ZKB):</strong><br>';
        data.slice(0,10).forEach(k=>{
            zkbKillsDiv.innerHTML += `${k.victim.shipTypeName} в ${k.solarSystemName} <br>`;
        });
    }catch(e){ zkbKillsDiv.innerHTML += 'Ошибка ZKB: '+e.message; }
}

// Получаем текущую систему через сервер
async function getCurrentSystem(charID){
    try{
        const r = await fetch(`${RENDER_SERVER}/location?characterID=${charID}`);
        if(!r.ok) return null;
        const data = await r.json();
        return data; // { system_id, system_name }
    }catch(e){ console.error(e); return null; }
}

// Сохраняем текущую систему на сервер
async function saveCurrentSystem(characterID, system){
    try {
        await fetch(`${RENDER_SERVER}/location`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                characterID,
                systemID: system.system_id,
                systemName: system.system_name
            })
        });
    } catch(e){ console.error('Ошибка сохранения системы:', e); }
}

// Получаем историю ВХ с сервера
async function getWHHistory(characterID){
    try{
        const r = await fetch(`${RENDER_SERVER}/history/${characterID}`);
        if(!r.ok) return [];
        const data = await r.json();
        return data.filter(s => isWormholeSystem(s.system_name));
    }catch(e){
        console.error('Ошибка получения истории:', e);
        return [];
    }
}

buildMapBtn.addEventListener('click', async ()=>{
    results.innerHTML = '';
    container.innerHTML = '';
    zkbKillsDiv.innerHTML = '<strong>Последние киллмейлы (ZKB):</strong><br>';
    historyWH = [];

    const char = JSON.parse(localStorage.getItem('eve_char'));
    const charID = char.CharacterID;
    const charName = char.CharacterName;

    try{
        status.textContent = 'Получаем историю ВХ и текущее местоположение...';

        const history = await getWHHistory(charID);

        let current = await getCurrentSystem(charID);
        if(!current && history.length>0){
            current = history[history.length-1]; // fallback
        }
        if(!current){
            status.textContent='Не удалось получить текущее местоположение';
            return;
        }

        await saveCurrentSystem(charID, current);

        if(isWormholeSystem(current.system_name)){
            historyWH.push({id: current.system_id, system_name: current.system_name});
        }
        history.forEach(s=> historyWH.push(s));

        const nodes = [];
        const edges = [];
        nodes.push(charName);
        let lastNode = 0;
        historyWH.forEach(s=>{
            nodes.push(s.system_name);
            edges.push({from:lastNode,to:nodes.length-1});
            lastNode = nodes.length-1;
        });
        drawNetwork(nodes, edges);

        const html = [];
        html.push('<h3>История перемещений ВХ:</h3><ul>');
        historyWH.forEach(s=> html.push(`<li>${s.system_name}</li>`));
        html.push('</ul>');
        results.innerHTML = html.join('');

        status.textContent='Готово';
        fetchZKBBattles(charID);

    }catch(e){
        console.error(e);
        status.textContent='Ошибка: '+e.message;
    }
});

savePathBtn.addEventListener('click', ()=>{
    if(historyWH.length===0){ alert('Нет данных для сохранения'); return; }
    const blob = new Blob([JSON.stringify(historyWH,null,2)],{type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'WH_path.json';
    a.click();
    URL.revokeObjectURL(url);
});
</script>
</body>
</html>
