<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>EVE — Карта перемещений ВХ с маршрутом</title>
<script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
<style>
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:16px}
button{font-size:1rem;padding:6px;margin:4px}
#map{width:100%;height:480px;border:1px solid #ddd;margin-top:12px}
#results{margin-top:12px}
#zkbKills{margin-top:12px;border:1px solid #ddd;padding:8px;height:220px;overflow:auto;background:#f9f9f9}
.note{color:#555;font-size:0.9rem}
.copyBtn{margin-left:6px;padding:2px 4px;font-size:0.8rem;cursor:pointer}
</style>
</head>
<body>
<h2>EVE Online — Карта перемещений ВХ с маршрутом</h2>
<p class="note">Карта перемещений персонажа через вормхолы. Последние киллмейлы берутся с ZKillboard, ссылки можно копировать.</p>

<div>
<button id="authBtn">Авторизоваться через EVE Online</button>
<button id="logoutBtn" style="display:none">Выйти</button>
</div>
<div id="authInfo" class="note"></div>
<div>
<button id="buildMapBtn" style="display:none">Построить карту ВХ</button>
<button id="savePathBtn" style="display:none">Сохранить путь</button>
<button id="clearPathBtn" style="display:none">Очистить путь</button>
</div>

<div id="status" class="note"></div>
<div id="map"></div>
<div id="results"></div>
<div id="zkbKills"><strong>Последние киллмейлы (ZKB):</strong><br></div>

<script>
const CLIENT_ID = '5a40c55151c241e3a007f2562fd4e1dd';
const REDIRECT_URI = window.location.origin + window.location.pathname;
const SCOPES = 'esi-location.read_location.v1';
const PROXY_URL = 'https://eve-proxy.onrender.com/exchange';
const RENDER_SERVER = 'https://eve-proxy.onrender.com';

const authBtn = document.getElementById('authBtn');
const logoutBtn = document.getElementById('logoutBtn');
const buildMapBtn = document.getElementById('buildMapBtn');
const savePathBtn = document.getElementById('savePathBtn');
const clearPathBtn = document.getElementById('clearPathBtn');
const authInfo = document.getElementById('authInfo');
const status = document.getElementById('status');
const results = document.getElementById('results');
const zkbKillsDiv = document.getElementById('zkbKills');
const container = document.getElementById('map');

let historyWH = [];

function login(){
    const state = Math.random().toString(36).substring(2);
    const url = `https://login.eveonline.com/v2/oauth/authorize?response_type=code&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&client_id=${CLIENT_ID}&scope=${encodeURIComponent(SCOPES)}&state=${state}`;
    window.location.href = url;
}

async function exchangeCodeForToken(code){
    const r = await fetch(PROXY_URL, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ code })
    });
    if(!r.ok) throw new Error('Ошибка обмена кода на токен');
    return await r.json();
}

async function getCharacterInfo(token){
    const r = await fetch('https://esi.evetech.net/verify/',{headers:{Authorization:`Bearer ${token}`}});
    if(!r.ok) throw new Error('Ошибка проверки токена');
    return await r.json();
}

function logout(){
    localStorage.removeItem('eve_token');
    localStorage.removeItem('eve_char');
    authInfo.textContent = '';
    authBtn.style.display = 'inline-block';
    logoutBtn.style.display = 'none';
    buildMapBtn.style.display = 'none';
    savePathBtn.style.display = 'none';
    clearPathBtn.style.display = 'none';
}

async function getRealCurrentSystem(token, charID){
    try{
        const r = await fetch(`https://esi.evetech.net/latest/characters/${charID}/location/`,{
            headers: { Authorization: `Bearer ${token}` }
        });
        if(!r.ok) throw new Error('Не удалось получить текущее местоположение через ESI');
        const data = await r.json();
        const rName = await fetch(`https://esi.evetech.net/latest/universe/systems/${data.solar_system_id}/`);
        if(!rName.ok) throw new Error('Не удалось получить имя системы');
        const systemData = await rName.json();
        return { system_id: data.solar_system_id, system_name: systemData.name };
    }catch(e){
        console.error(e);
        return null;
    }
}

async function handleAuth(){
    const params = new URLSearchParams(window.location.search);
    let char, token;

    if(params.has('code')){
        const code = params.get('code');
        try{
            const tokenData = await exchangeCodeForToken(code);
            token = tokenData.access_token;
            const verify = await getCharacterInfo(token);
            char = verify;
            localStorage.setItem('eve_token', token);
            localStorage.setItem('eve_char', JSON.stringify(char));
            authInfo.textContent = `Авторизован: ${char.CharacterName} (ID: ${char.CharacterID})`;
            authBtn.style.display = 'none';
            logoutBtn.style.display = 'inline-block';
            buildMapBtn.style.display = 'inline-block';
            savePathBtn.style.display = 'inline-block';
            clearPathBtn.style.display = 'inline-block';

            const realSystem = await getRealCurrentSystem(token, char.CharacterID);
            if(realSystem){
                await fetch(`${RENDER_SERVER}/location`, {
                    method:'POST',
                    headers:{ 'Content-Type':'application/json' },
                    body: JSON.stringify({
                        characterID: char.CharacterID,
                        systemID: realSystem.system_id,
                        systemName: realSystem.system_name
                    })
                });
            }

            window.history.replaceState({}, document.title, window.location.pathname);

        }catch(e){
            console.error(e);
            authInfo.textContent = 'Ошибка авторизации: '+e.message;
        }
    } else {
        token = localStorage.getItem('eve_token');
        const charData = localStorage.getItem('eve_char');
        if(token && charData){
            char = JSON.parse(charData);
            authInfo.textContent = `Авторизован: ${char.CharacterName} (ID: ${char.CharacterID})`;
            authBtn.style.display = 'none';
            logoutBtn.style.display = 'inline-block';
            buildMapBtn.style.display = 'inline-block';
            savePathBtn.style.display = 'inline-block';
            clearPathBtn.style.display = 'inline-block';
        }
    }
}

authBtn.addEventListener('click', login);
logoutBtn.addEventListener('click', logout);
handleAuth();

function isWormholeSystem(name){ return /^J\d+/i.test(name); }

function drawNetwork(nodesArr, edgesArr){
    const nodes = new vis.DataSet(nodesArr.map((n,i)=>({id:i,label:n})));
    const edges = new vis.DataSet(edgesArr.map(e=>({from:e.from,to:e.to})));
    const data = { nodes, edges };
    const options = { physics:{stabilization:true, barnesHut:{gravitationalConstant:-8000}} };
    new vis.Network(container, data, options);
}

// ZKB через сервер-прокси
async function fetchZKBBattles(characterID){
    try{
        const r = await fetch(`${RENDER_SERVER}/zkb/${characterID}`);
        if(!r.ok) { zkbKillsDiv.innerHTML += 'Ошибка ZKB: '+r.status; return; }
        const data = await r.json();
        zkbKillsDiv.innerHTML = '<strong>Последние киллмейлы (ZKB):</strong><br>';
        data.slice(0,10).forEach(k=>{
            const link = `https://zkillboard.com/kill/${k.killID}/`;
            zkbKillsDiv.innerHTML += `${k.victim.shipTypeName} в ${k.solarSystemName} <a href="${link}" target="_blank">ZKB</a> <button class="copyBtn" onclick="navigator.clipboard.writeText('${link}')">Копировать</button><br>`;
        });
    }catch(e){ zkbKillsDiv.innerHTML += 'Ошибка ZKB: '+e.message; }
}

// Серверные функции
async function getWHHistory(characterID){
    try{
        const r = await fetch(`${RENDER_SERVER}/history/${characterID}`);
        if(!r.ok) return [];
        const data = await r.json();
        return data.filter(s => isWormholeSystem(s.system_name));
    }catch(e){ console.error('Ошибка получения истории:', e); return []; }
}

async function saveCurrentSystem(characterID, system){
    try{
        await fetch(`${RENDER_SERVER}/location`, {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({characterID, systemID: system.system_id, systemName: system.system_name})
        });
    }catch(e){ console.error('Ошибка сохранения системы:', e); }
}

// Построение карты
buildMapBtn.addEventListener('click', async ()=>{
    results.innerHTML = '';
    container.innerHTML = '';
    zkbKillsDiv.innerHTML = '<strong>Последние киллмейлы (ZKB):</strong><br>';
    historyWH = [];

    const char = JSON.parse(localStorage.getItem('eve_char'));
    const charID = char.CharacterID;
    const charName = char.CharacterName;
    const token = localStorage.getItem('eve_token');

    try{
        status.textContent = 'Получаем историю ВХ и текущее местоположение...';
        const history = await getWHHistory(charID);
        let current = await getRealCurrentSystem(token, charID);
        if(!current && history.length>0){ current = history[history.length-1]; }
        if(!current){ status.textContent='Не удалось получить текущее местоположение'; return; }

        await saveCurrentSystem(charID, current);

        if(isWormholeSystem(current.system_name)){ historyWH.push(current); }
        history.forEach(s=> historyWH.push(s));

        const nodes = [];
        const edges = [];
        nodes.push(charName);
        let lastNode = 0;
        historyWH.forEach((s,i)=>{
            nodes.push(s.system_name);
            edges.push({from:lastNode,to:nodes.length-1});
            if(i>0) edges.push({from:nodes.length-2,to:nodes.length-1});
            lastNode = nodes.length-1;
        });
        drawNetwork(nodes, edges);

        const html = [];
        html.push('<h3>История перемещений ВХ:</h3><ul>');
        historyWH.forEach(s=> html.push(`<li>${s.system_name}</li>`));
        html.push('</ul>');
        results.innerHTML = html.join('');

        status.textContent='Готово';
        fetchZKBBattles(charID);

    }catch(e){
        console.error(e);
        status.textContent='Ошибка: '+e.message;
    }
});

// Сохранение пути
savePathBtn.addEventListener('click', ()=>{
    if(historyWH.length===0){ alert('Нет данных для сохранения'); return; }
    const blob = new Blob([JSON.stringify(historyWH,null,2)],{type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'WH_path.json';
    a.click();
    URL.revokeObjectURL(url);
});

// Очистка пути на сервере и фронтенде
clearPathBtn.addEventListener('click', async ()=>{
    if(!confirm('Вы точно хотите очистить путь?')) return;
    const char = JSON.parse(localStorage.getItem('eve_char'));
    const charID = char.CharacterID;

    try{
        await fetch(`${RENDER_SERVER}/history/${charID}`,{method:'DELETE'});
    }catch(e){ console.error('Ошибка очистки на сервере:', e); }

    historyWH = [];
    container.innerHTML = '';
    results.innerHTML = '';
    zkbKillsDiv.innerHTML = '<strong>Последние киллмейлы (ZKB):</strong><br>';
    status.textContent = 'Путь очищен';
});
</script>
</body>
</html>
